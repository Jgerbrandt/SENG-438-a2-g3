**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#: 3    |
| -------------- |
| Aaron Frerichs |
| Avijot Gern    |
| Jesse Gerbrandt|
| Ethan Subasic  |

# 1 Introduction

&emsp;Within this lab, our team worked together to develop tests on the provided systems. This exercise was an example of blackbox testing, as the source code of the system under test was not revealed to us. Therefore, it was required that design documents for the classes under test to be analyzed, with methods from these documents chosen for testing. Tests were developed with junit and were able to successfully test basic functionality as well as boundary cases of the system.

# 2 Detailed description of unit test strategy

&emsp;Our team's decided strategy is to employ commonly used black-box testing techniques, with a heavier emphasis on boundary value analysis and equivalence partitioning. For the Range method tests, we will partition the values being tested into valid and invalid inputs, this will mainly be tested in the "contains" method, but we will apply it to other tests as needed. Boundary value analysis will be a big part of our testing procedure, and will be used wherever applicable. With this, we plan on testing edge cases, as well as using inputs that violate the max and min values. The aforementioned testing techniques will be used to create our test cases, and we will attempt to cover every method as thoroughly as we can (given the method specifications).


| Method                                                           | Invalid | Valid | Invalid |
|---|---|---|---|
| ```contains()```                                                       | input < 0 | 0 <= input <= 100 | input > 100 |
| ```getUpperBound()```                                                  | input <= 99 | input = 100 | input >= 101 |
| ```getLowerBound()```                                                  | input <= -1 | input = 0 | input >= 1 |
| ```intersects()```                                                     | input lower bound > 100 | 0 < input lower bound < 100<br>or<br> 0 < input upper bound < 100 | input upper bound < 0 |

*Table 2.1: Example of Equivalence Partitioning for Range Class using an example range of \[0-100\]*

<br>
Drawbacks and Benefits of Mocking:<br>
    &emsp;Some drawbacks of mocking include difficulty creating mocks, understanding test cases written using mocks, and inconsistencies between mocks and the real objects. For someone creating mocks, it can be a tough concept to grasp, and can result in a lot of trial and error before getting anywhere close to the desired result. The same goes for someone looking over mocked tests, it can be difficult to trace a test case when there is so much more code involved - it can get messy quick. Another issue that arises with mocks is inconsistencies as compared to the actual program objects. During black-box testing, since the tester does not have direct access to the code and inner workings of the program, they may create a mock that works how it's supposed to, however the real object may end up having something wrong with it. If this is the case, the tests will pass with the mock, but since the object is wrong, the program may fail outside of testing. These inconsistencies can skew testing results, and provide a false sense of security, or conversly respond with failure even though the real program should have passed.

<br>&emsp;The main benefits of Mock testing include test isolation and efficient load testing. By using mocks, a programmer can isolate certain tests, without having to worry about other dependencies interfering. A mock does exactly what the name implies, you can mock objects in the program, and completely avoid using and testing everything involved in running a single method. For example, if we have a method that takes in an Object as an argument, you can mock said object and get straight to testing your desired method - instead of first testing the original object, then testing if it passes in correctly, then finally testing the desired method. Another benefit of mocks, is load testing. With the creation of many mocks, you can very easily test the limits and load handling of a system, by multiplying the number of mocks in the system. In this way, again, you do not need to worry about hanndling the normal objects, instead you can make it easier and work with simplified mocks. 


# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

&emsp;Over this lab, the team worked collaboratively in order to successfully complete the assignment. All group members were responsible for an equal share of work and completed their portions on time. Jesse and Ethan managed the mock tests (applied pair programming with Avi/Aaron) while Aaron and Avi managed the tests for Range. The entire team collaborated on the lab document. 

# 5 Difficulties encountered, challenges overcome, and lessons learned

&emsp;Getting started on using Eclipse was a challenge within this lab, especially with the lab instructions being on an outdated version of Eclipse. Additionally, none of the team had much experience with Eclipse, so learning a new program added additional problems to the assignment. After some trial and error, and utilizing pair-programming, we were able to overcome confusion regarding the Eclipse IDE, as well as understanding the techniques of black-box testing. The main lessons learned by all group members were gaining a better understanding of mock testing, as well as getting familiar with JUnit testing procedures. 

# 6 Comments/feedback on the lab itself

No further comments or feedback on the lab. 