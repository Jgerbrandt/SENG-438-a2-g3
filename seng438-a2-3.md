**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#: 3    |
| -------------- |
| Aaron Frerichs |
| Avijot Gern    |
| Jesse Gerbrandt|
| Ethan Subasic  |

# 1 Introduction

&emsp;Within this lab, our team worked together to develop tests on the provided systems. This exercise was an example of blackbox testing, as the source code of the system under test was not revealed to us. Therefore, it was required that design documents for the classes under test to be analyzed, with methods from these documents chosen for testing. Tests were developed with junit and were able to successfully test basic functionality as well as boundary cases of the system.

# 2 Detailed description of unit test strategy

&emsp;Our team's decided strategy is to employ commonly used black-box testing techniques, with a heavier emphasis on boundary value analysis and equivalence partitioning. For the Range method tests, we will partition the values being tested into valid and invalid inputs, this will mainly be tested in the "contains" method, but we will apply it to other tests as needed. Boundary value analysis will be a big part of our testing procedure, and will be used wherever applicable. With this, we plan on testing edge cases, as well as using inputs that violate the max and min values. The aforementioned testing techniques will be used to create our test cases, and we will attempt to cover every method as thoroughly as we can (given the method specifications).


| Method                                                           | Invalid | Valid | Invalid |
|---|---|---|---|
| ```contains()```                                                       | input < 0 | 0 <= input <= 100 | input > 100 |
| ```getUpperBound()```                                                  | input <= 99 | input = 100 | input >= 101 |
| ```getLowerBound()```                                                  | input <= -1 | input = 0 | input >= 1 |
| ```intersects()```                                                     | input lower bound > 100 | 0 < input lower bound < 100<br>or<br> 0 < input upper bound < 100 | input upper bound < 0 |

*Table 2.1: Example of Equivalence Partitioning for Range Class using an example range of \[0-100\]*

<br>
&emsp;Refer to Table 2.1 above to get an idea of how we organized our ECT procedures. For us, it was more of a visualization tool rather than a strict procedure to follow, hence why the above table is just an example, we did not create tables to be followed for Eq. Partitioning. 

<br>
Drawbacks and Benefits of Mocking:<br>
    &emsp;Some drawbacks of mocking include difficulty creating mocks, understanding test cases written using mocks, and inconsistencies between mocks and the real objects. For someone creating mocks, it can be a tough concept to grasp, and can result in a lot of trial and error before getting anywhere close to the desired result. The same goes for someone looking over mocked tests, it can be difficult to trace a test case when there is so much more code involved - it can get messy quick. Another issue that arises with mocks is inconsistencies as compared to the actual program objects. During black-box testing, since the tester does not have direct access to the code and inner workings of the program, they may create a mock that works how it's supposed to, however the real object may end up having something wrong with it. If this is the case, the tests will pass with the mock, but since the object is wrong, the program may fail outside of testing. These inconsistencies can skew testing results, and provide a false sense of security, or conversly respond with failure even though the real program should have passed.

<br>&emsp;The main benefits of Mock testing include test isolation and efficient load testing. By using mocks, a programmer can isolate certain tests, without having to worry about other dependencies interfering. A mock does exactly what the name implies, you can mock objects in the program, and completely avoid using and testing everything involved in running a single method. For example, if we have a method that takes in an Object as an argument, you can mock said object and get straight to testing your desired method - instead of first testing the original object, then testing if it passes in correctly, then finally testing the desired method. Another benefit of mocks, is load testing. With the creation of many mocks, you can very easily test the limits and load handling of a system, by multiplying the number of mocks in the system. In this way, again, you do not need to worry about hanndling the normal objects, instead you can make it easier and work with simplified mocks. 


# 3 Test cases developed

| **Class**                        | **Method**                                          | **Test Plan (Description)**                                                                                       | **P/F**                                                                                                 |
| ---------------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| org.jfree.data.Range         | ```contains()```                                      | Testing if a number in the range is recognized.                                                               | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Testing a number not in the range, greater than the upper bound is handled.                                   | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Test a value not in the range, less than the lower bound.                                                     | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Test the upper bound itself (inclusive range or not)                                                          | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Test lower bound itself (lower bound inclusive)                                                               | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Test if an entirely positive range handles a negative value properly (should not contain)                     | P                                                                                                   |
| org.jfree.data.Range         | ```contains()```                                      | Test if an entirely negative range contains a negative value.                                                 | P                                                                                                   |
| org.jfree.data.Range         | ```getUpperBound()```                                 | Test correct upper bound on positive-only range (what should be the correct one)                              | F: Expected correct upper bound, returned lower bound instead.                                      |
| org.jfree.data.Range         | ```getUpperBound()```                                 | Test correct upper bound on a negative-only range                                                             | F: Expected correct upper bound, returned lower bound instead.                                      |
| org.jfree.data.Range         | ```getUpperBound()```                                 | Test incorrect upper bound on a range                                                                         | P                                                                                                   |
| org.jfree.data.Range         | ```getLowerBound()```                                 | Test correct lower bound on a positive-only range                                                             | P                                                                                                   |
| org.jfree.data.Range         | ```getLowerBound()```                                 | Test correct lower bound on a negative-only range                                                             | P                                                                                                   |
| org.jfree.data.Range         | ```getLowerBound()```                                 | Test incorrect lower bound on a range                                                                         | P                                                                                                   |
| org.jfree.data.Range         | ```getLength()```                                     | Test correct length on a range                                                                                | P                                                                                                   |
| org.jfree.data.Range         | ```getLength()```                                     | Test incorrect length comparison on a range                                                                   | P                                                                                                   |
| org.jfree.data.Range         | ```getLength()```                                     | Test correct length comparison on a negative-only range                                                       | P                                                                                                   |
| org.jfree.data.Range         | ```intersects()```                                    | Test input that should not intersect with the given range                                                     | P                                                                                                   |
| org.jfree.data.Range         | ```intersects()```                                    | Test input range that overlaps with only the upper bound of the given range                                   | F: Return false, indicating that there is no intersection when there actually should have been      |
| org.jfree.data.Range         | ```intersects()```                                    | Test input range that lies within the given range (full overlap/intersect)                                    | P                                                                                                   |
| org.jfree.data.Range         | ```intersects()```                                    | Test input range that overlaps with only the lower bound of the given range                                   | P                                                                                                   |
| org.jfree.data.DataUtilities | ```calculateColumnTotal(Values2D data, int column)``` | Testing sum of values in a given column using mocking. (Pre-made test, given)                                 | P                                                                                                   |
| org.jfree.data.DataUtilities | ```calculateColumnTotal(Values2D data, int column)``` | Testing sum of values in given column index using mocking, custom 2D array.                                   | P                                                                                                   |
| org.jfree.data.DataUtilities | ```calculateColumnTotal(Values2D data, int column)``` | Test passing in invalid column index value (negative index).                                                  | F: Should return 0, instead throws IndexOutOfBoundsException                                        |
| org.jfree.data.DataUtilities | ```calculateColumnTotal(Values2D data, int column)``` | Test passing in a value larger than the array size.                                                           | F: Should return 0, instead throws IndexOutOfBoundsException.                                       |
| org.jfree.data.DataUtilities | ```calculateRowTotal(Values2D data, int row)```       | Test calculating the values’ total in a given row index, using mocking.                                       | F: Did not add up the values, instead just returned the value at the given row index (with col = 0) |
| org.jfree.data.DataUtilities | ```calculateRowTotal(Values2D data, int row)```       | Test passing in a negative index value.                                                                       | F: Should return 0, instead throws IndexOutOfBoundsException.                                       |
| org.jfree.data.DataUtilities | ```calculateRowTotal(Values2D data, int row)```       | Test passing in an index value that is too large (out of bounds)                                              | F: Should return 0, instead throws index out of bounds exception                                    |
| org.jfree.data.DataUtilities | ```createNumberArray(double[] data)```                | Test creating an array given a valid double[] input.                                                          | F: NumberArray seemingly drops the last element of the array passed into the arg.                   |
| org.jfree.data.DataUtilities | ```createNumberArray(double[] data)```                | Test creating a NumberArray by passing in an empty array as the arg. Should create an empty NumberArray       | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray(double[] data)```                | Test passing in an array with an element 0 in it. Should not produce any errors/exceptions                    | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray(double[] data)```                | Test passing in an array with negative elements. Should not produce any errors.                               | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating a 2d NumberArray given a valid 2d array argument.                                               | F: Seemingly replaces the last element of the first row with null.                                  |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating 2dNumberArray using an empty main array as the argument. Should produce no errors.              | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating 2dNumberArray using an empty subarray as the argument. Should produce no errors.                | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating 2DNumArr with the arg array having a different sized subarray compared to the main array.       | F: Seemingly dropped the first element, and replaced it with a null                                 |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating 2DNumArr with 0 values in the arg array. Should not produce any errors                          | P                                                                                                   |
| org.jfree.data.DataUtilities | ```createNumberArray2D(double[][] data)```            | Test creating 2DNumArr with negative values in the arg array. Should produce no errors.                       | P                                                                                                   |
| org.jfree.data.DataUtilities | ```getCumulativePercentages(KeyedValues data)```      | Test passing in a null value, should throw InvalidParameterException. Test using mocked KeyedValue interface. | F: Threw IllegalArgumentException.                                                                  |
| org.jfree.data.DataUtilities | ```getCumulativePercentages(KeyedValues data)```      | Test valid mocked KeyedValues input, should return correct for the first value, no errors.                    | F: Returned incorrect value.                                                                        |
| org.jfree.data.DataUtilities | ```getCumulativePercentages(KeyedValues data)```      | Test valid mocked KeyedValues input, should return correct for the second value, no errors.                   | F: Returned incorrect value                                                                         |
| org.jfree.data.DataUtilities | ```getCumulativePercentages(KeyedValues data)```     | Test valid mocked KeyedValues input, should return correct for the third value, no errors.                    | F: Returned incorrect value                                                                         |

# 4 How the team work/effort was divided and managed

&emsp;Over this lab, the team worked collaboratively in order to successfully complete the assignment. All group members were responsible for an equal share of work and completed their portions on time. Jesse and Ethan managed the mock tests (applied pair programming with Avi/Aaron) while Aaron and Avi managed the tests for Range. The entire team collaborated on the lab document. 

# 5 Difficulties encountered, challenges overcome, and lessons learned

&emsp;Getting started on using Eclipse was a challenge within this lab, especially with the lab instructions being on an outdated version of Eclipse. Additionally, none of the team had much experience with Eclipse, so learning a new program added additional problems to the assignment. After some trial and error, and utilizing pair-programming, we were able to overcome confusion regarding the Eclipse IDE, as well as understanding the techniques of black-box testing. The main lessons learned by all group members were gaining a better understanding of mock testing, as well as getting familiar with JUnit testing procedures. 

# 6 Comments/feedback on the lab itself

&emsp;This lab was very informative and educational, it really helped our group solidify the concepts surrounding JUnit testing and Mocking. We felt that the instructions were clear and well presented, and the steps to understanding JUnit testing and setting up Eclipse IDE were good.